package internal.org.springframework.content.jpa.store;

import com.github.paulcwarren.ginkgo4j.Ginkgo4jRunner;
import org.junit.runner.RunWith;

import javax.sql.DataSource;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.Statement;

import static com.github.paulcwarren.ginkgo4j.Ginkgo4jDSL.*;
import static org.junit.Assert.assertFalse;
import static org.mockito.Matchers.anyString;
import static org.mockito.Mockito.*;

@RunWith(Ginkgo4jRunner.class)
public class JpaStoreSchemaManagerTest {

    private DataSource ds;

    private JpaStoreSchemaManager manager;

    private ResultSet rs;
    private Statement statement;

    {
        Describe("JpaStoreSchemaManager", () -> {
            BeforeEach(() -> {
                ds = mock(DataSource.class);
            });
            JustBeforeEach(() -> {
                manager = new JpaStoreSchemaManager(ds);
            });
            Context("#create", () -> {
                JustBeforeEach(() -> {
                    manager.create();
                });
                Context("when the table does not exist", () -> {
                    BeforeEach(() -> {
                        Connection con = mock(Connection.class);
                        DatabaseMetaData metaData = mock(DatabaseMetaData.class);
                        rs = mock(ResultSet.class);
                        when(ds.getConnection()).thenReturn(con);
                        when(con.getMetaData()).thenReturn(metaData);
                        when(metaData.getTables(null, null, "BLOBS", new String[] {"TABLE"})).thenReturn(rs);
                        when(rs.next()).thenReturn(false);

                        statement = mock(Statement.class);
                        when(con.createStatement()).thenReturn(statement);
                    });
                    It("should execute create table statement against the database", () -> {
                        verify(statement).executeUpdate("CREATE TABLE BLOBS " +
                                "(id INTEGER GENERATED BY DEFAULT AS IDENTITY (START WITH 1), " +
                                " blob BLOB, " +
                                " PRIMARY KEY ( id ))");
                    });
                    It("should close the statement", () -> {
                        verify(statement).close();
                    });
                    It("should close the resultset", () -> {
                        verify(rs).close();
                    });
                });
                Context("when the table already exists", () -> {
                    BeforeEach(() -> {
                        Connection con = mock(Connection.class);
                        DatabaseMetaData metaData = mock(DatabaseMetaData.class);
                        rs = mock(ResultSet.class);
                        when(ds.getConnection()).thenReturn(con);
                        when(con.getMetaData()).thenReturn(metaData);
                        when(metaData.getTables(null, null, "BLOBS", new String[] {"TABLE"})).thenReturn(rs);
                        when(rs.next()).thenReturn(true);

                        statement = mock(Statement.class);
                        when(con.createStatement()).thenReturn(statement);
                    });
                    It("should execute create table statement against the database", () -> {
                        verify(statement, never()).executeUpdate(anyString());
                    });
                    It("should close the resultset", () -> {
                        verify(rs).close();
                    });
                });
            });
        });
    }
}
